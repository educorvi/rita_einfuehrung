{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#was-lese-ich-hier","title":"Was lese ich hier?","text":"<p>Diese Dokumentation hat zum Ziel, dem Nutzer ein Verst\u00e4ndnis f\u00fcr Rita und eine Einf\u00fchrung in die Nutzung des Projekts zu geben.</p>"},{"location":"1.%20Einf%C3%BChrung/01_rita/","title":"Was ist Rita?","text":""},{"location":"1.%20Einf%C3%BChrung/01_rita/#das-problem","title":"Das Problem","text":"<p>Das Ausgangsproblem ist, eine gro\u00dfe Menge von Daten (z. B. Formulare) gegen festgelegte Regeln auszuwerten. In diesem Kontext stellt sich zun\u00e4chst die Frage, wie man diese Regeln formulieren kann, um sie sowohl f\u00fcr den Nutzer als auch den Computer verst\u00e4ndlich zu machen.</p>"},{"location":"1.%20Einf%C3%BChrung/01_rita/#die-losung","title":"Die L\u00f6sung","text":"<p>Hier kommt nun Rita (\"Rule it all\") ins Spiel. Das Projekt besteht aus mehreren Teilen:</p> <ul> <li>Die Sprache, in der die Regeln formuliert werden</li> <li>Ein Parser, der die in der Sprache geschriebenen Regeln parst und so f\u00fcr den Computer verwertbar macht</li> <li>Weitere Projekte, die auf diesen Bausteinen aufbauen, so zum Beispiel ein Webserver, der eine REST Api zur Verf\u00fcgung stellt, um Rita Regeln zu verwalten und mit Daten auszuwerten</li> </ul>"},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/","title":"Eine erste Regel","text":"<p>In diesem Kapitel soll es darum gehen, unsere erste eigene einfache Regel zu schreiben. Das Beispiel daf\u00fcr soll folgende Regel sein:</p> <p>Beispiel</p> <p>Die Person, deren Daten \u00fcbergeben wurden, darf kein Mitarbeiter sein und muss einen Computer haben.</p>"},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/#von-naturlicher-sprache-zur-logik","title":"Von nat\u00fcrlicher Sprache zur Logik","text":"<p>Der erste Schritt ist, sich klarzumachen, was eigentlich die Anforderungen der Regel sind, und wie diese zusammenh\u00e4ngen. </p> <p>Unsere Regel besteht aus zwei Teilen, die durch ein \"und\" miteinander verbunden sind. Diese sind \"hat einen Computer\" und \"ist nicht Mitarbeiter\". Letzteres l\u00e4sst sich auch wieder zerlegen, n\u00e4mlich in \"nicht\" und \"ist Mitarbeiter\". Dieses hierarchische Zerlegen l\u00e4sst sich gut als Baum visualisieren: <pre><code>graph\n\nu(Und) --&gt; n(Nicht)\nu --&gt; e(hat Computer)\nn --&gt; m(Mitarbeiter)</code></pre></p>"},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/#unsere-regel-in-rita","title":"Unsere Regel in Rita","text":""},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/#einleitung","title":"Einleitung","text":"<p>Nachdem wir verstanden haben, was unsere Regel eigentlich sagt, k\u00f6nnen wir nun beginnen, sie tats\u00e4chlich im Rita Format aufzuschreiben. </p> <p>Rita Regeln werden im JSON Format geschrieben. Deshalb muss zun\u00e4chst eine JSON Datei erstellt werden. Es gibt ein JSON Schema, das beschreibt und \u00fcberpr\u00fcft, wie Regeln geschrieben werden sollen. Auch wenn es optional ist, empfiehlt es sich, dieses in der Datei anzugeben, da dann Code Editoren wie zum Beispiel VS Code oder die JetBrains IDEs Autovervollst\u00e4ndigung anbieten und Fehler bem\u00e4ngeln.</p> <p>Rita ist so angelegt, dass eine wie die eben angelegte Datei stets ein sogenanntes Ruleset enth\u00e4lt, also nicht nur eine Regel, sondern eine Menge von Regeln. Zu Beginn sieht unsere Datei also so aus: <pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": []\n}\n</code></pre> In Zeile 1 steht die bereits erw\u00e4hnte Angabe des JSON Schemas, in Zeile 2 steht ein (noch leeres) Array von Regeln, in das wir nun unsere Regel schreiben wollen.</p>"},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/#die-regel","title":"Die Regel","text":"<p>Zun\u00e4chst erg\u00e4nzen wir das <code>rules</code> Array um ein JSON Objekt, das unsere Regel beschreibt:</p> <p><pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"example1\",\n      \"rule\": {...}\n    }\n  ]\n}\n</code></pre> Die Regel muss eine im Ruleset eindeutige ID enthalten und eine Formel, die die Regel beschreibt. F\u00fcr diese Formel gibt es mehrere Optionen, die f\u00fcr den Anfang interessanten sind <code>and</code>, <code>or</code>, <code>not</code> und <code>atom</code>.</p> <p><code>and</code>, <code>or</code> und <code>not</code> tun das, was man intuitiv vermuten w\u00fcrde: Sie nehmen jeweils wieder Formeln als Argumente und entsprechen in ihrer Funktion dem logischen und, oder &amp; nicht.</p> <p><code>atom</code> ist daf\u00fcr da, Informationen aus den \u00fcbergebenen Daten auszulesen, indem man den Pfad der gew\u00fcnschten Information in den Daten angibt. Bekommen wir bei der Auswertung der Regel zum Beispiel folgendes Datenobjekt \u00fcbergeben...</p> <p><pre><code>{\n  \"info1\": false,\n  \"info2\": {\n    \"test\": true\n  }\n}\n</code></pre> ...k\u00f6nnten wir mit dem Pfad <code>info1</code> den Wert von info1 (<code>false</code>), mit dem Pfad <code>info2.test</code> den Wert von test (<code>true</code>) abrufen.</p>"},{"location":"1.%20Einf%C3%BChrung/02_eine_erste_regel/#anwendung","title":"Anwendung","text":"<p>Wenden wir das Gelernte nun also an und setzen unsere Regel als Rita Regel um. Zur Erinnerung:</p> <p>Die Person, deren Daten \u00fcbergeben wurden, darf kein Mitarbeiter sein und muss einen Computer haben. <pre><code>graph\n\nu1(Und) --&gt; n1(Nicht)\nu1 --&gt; e1(hat Computer)\nn1 --&gt; m1(Mitarbeiter)</code></pre></p> <p>Wir gehen davon aus, dass wir die Daten in folgendem Format \u00fcbergeben bekommen: <pre><code>{\n    \"hatComputer\": true/false,\n    \"mitarbeiter\": true/false\n}\n</code></pre> Da wir auf der obersten Ebene ein \"Und\" haben, beginnen wir mit einem <code>and</code></p> <p><pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"example1\",\n      \"rule\": {\n        \"type\": \"and\",\n        \"arguments\": [\n          //hat Computer,\n          //nicht Mitarbeiter\n        ]\n      }\n    }\n  ]\n}\n</code></pre> Das Argument \"Hat Computer\" k\u00f6nnen wir nun mit einem Atom aus den Daten auslesen: <pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"example1\",\n      \"rule\": {\n        \"type\": \"and\",\n        \"arguments\": [\n          {\n            \"type\": \"atom\",\n            \"path\": \"hatComputer\"\n          }\n          //nicht Mitarbeiter\n        ]\n      }\n    }\n  ]\n}\n</code></pre> \"Mitarbeiter\" kann auf die selbe Weise ausgelesen werden. Allerdings verlangt unsere Formel ja gerade \"nicht Mitarbeiter\". Deshalb m\u00fcssen wir das <code>atom</code>  in ein <code>not</code> schreiben:</p> <p><pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"example1\",\n      \"rule\": {\n        \"type\": \"and\",\n        \"arguments\": [\n          {\n            \"type\": \"atom\",\n            \"path\": \"hatComputer\"\n          },\n          {\n            \"type\": \"not\",\n            \"arguments\": [\n              {\n                \"type\": \"atom\",\n                \"path\": \"mitarbeiter\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ]\n}\n</code></pre>  Das erste Ruleset ist geschrieben! Im n\u00e4chsten Kapitel werden wir einen Webserver installieren, auf dem man dieses Ruleset speichern und Daten dagegen auswerten kann. In den sp\u00e4teren Kapiteln wird es dann um komplexere Regeln gehen, zum Beispiel mit Vergleichen oder Berechnungen.</p>"},{"location":"2.%20Der%20Server/03_installation/","title":"Installation","text":"<p>Bevor wir nun praktisch versuchen erste Regeln auszuwerten, m\u00fcssen wir zun\u00e4chst Rita aufsetzen. Daf\u00fcr werden wir den bereits erw\u00e4hnten Server installieren, der einer REST Api f\u00fcr Rita bereitstellt.</p> <p>Dies kann entweder mit Docker oder mit einer manuellen Installation geschehen. Nach der Installation wird der Server unter der Adresse http://localhost:3000 aufrufbar sein.</p> DockerManuelle Installation"},{"location":"2.%20Der%20Server/03_installation/#benotigte-software","title":"Ben\u00f6tigte Software","text":"<ul> <li>Docker</li> <li>Docker Compose</li> </ul>"},{"location":"2.%20Der%20Server/03_installation/#setup","title":"Setup","text":"<p>Erstellen Sie zun\u00e4chst die Datei <code>docker-compose.yaml</code> mit folgendem Inhalt: <pre><code>version: '3'\n\nservices:\n    mysql:\n        image: mysql:8\n        container_name: mysql\n        environment:\n            MYSQL_RANDOM_ROOT_PASSWORD: 1\n            MYSQL_DATABASE: rita\n            MYSQL_USER: rita\n            MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n\n    rita-http:\n        depends_on:\n            - mysql\n        image: ghcr.io/educorvi/rita-http:3-latest\n        container_name: rita-http\n        environment:\n            WAIT_HOSTS: mysql:3306\n            PORT: 3000\n            LOGLEVEL: info\n            DB_TYPE: MYSQL\n            DB_HOST: mysql\n            DB_PORT: 3306\n            DB_USERNAME: rita\n            DB_PASSWORD: ${MYSQL_PASSWORD}\n            DB_DATABASE: rita\n        ports:\n            - '3000:3000'\n</code></pre> Weiterhin muss im selben Ordner noch eine Datei mit dem Namen <code>.env</code> angelegt werden, die ein Passwort f\u00fcr die MySql Datenbank festlegt: <pre><code>MYSQL_PASSWORD=SOME_RANDOM_PASSWORD \n</code></pre> Nun kann der Server ausgef\u00fchrt werden, indem im selben Ordner, in dem auch die oben erw\u00e4hnten Dateien liegen, folgender Befehl ausgef\u00fchrt wird: <pre><code>docker compose up -d\n</code></pre> Heruntergefahren werden kann der Server mit <code>docker compose down</code>.</p>"},{"location":"2.%20Der%20Server/03_installation/#benotigte-software_1","title":"Ben\u00f6tigte Software","text":"<ul> <li>Node.js</li> </ul>"},{"location":"2.%20Der%20Server/03_installation/#source","title":"Source","text":"<p>Zun\u00e4chst muss das Repository geklont werden: <pre><code>git clone -b main https://github.com/educorvi/rita.git\ncd rita\n</code></pre></p>"},{"location":"2.%20Der%20Server/03_installation/#bauen-und-starten-der-software","title":"Bauen und Starten der Software","text":"<pre><code># Installieren der Abh\u00e4ngigkeiten und Bauen\n./setup.sh\n\n# Wechsel in das rita-http Verzeichnis\ncd rita-http\n\n# Konfigurieren der .env Datei\ncp .env.template .env\n\n# In der .env Datei LOGLEVEL auf \"info\" und DB_TYPE auf \"SQLITE\" setzen \n# und bei Bedarf andere Einstellungen vornehmen\n\n# HTTP Server starten\nnode .\n</code></pre>"},{"location":"2.%20Der%20Server/04_webserver/","title":"Einrichten des Webservers","text":"<p>Der Webserver l\u00e4uft nun unter dem Port 3000 (oder einem anderen Port, falls entsprechend ge\u00e4ndert). Ruft man nun den Server auf (http://localhost:3000), erh\u00e4lt man ein JSON Objekt mit Informationen \u00fcber selbigen: <pre><code>{\n  \"version\": \"3.1.2\",\n  \"message\": \"Welcome to the RITA API. A documentation is available under ./docs.\",\n  \"ritaVersion\": \"4.0.0\",\n  \"plugins\": [\n    {\n      \"name\": \"http\",\n      \"version\": \"1.1.0\"\n    }\n  ]\n}\n</code></pre> Enthalten sind unter anderem die Version des Servers, die installierte Rita-Version, sowie alle Plugins und deren Versionen.</p>"},{"location":"2.%20Der%20Server/04_webserver/#swagger-ui","title":"Swagger UI","text":"<p>Unter http://localhost:3000/docs befindet sich eine Dokumentation der aufrufbaren URLs. Au\u00dferdem bietet die Swagger UI eine Oberfl\u00e4che, um diese Endpunkte auszuprobieren.</p>"},{"location":"2.%20Der%20Server/04_webserver/#konfigurieren-des-zugriffs","title":"Konfigurieren des Zugriffs","text":"<p>F\u00fcr die Zwecke dieses Tutorials ist es sinnvoll, dem anonymen Nutzer alle Rechte einzur\u00e4umen, damit kein API Key eingegeben werden muss. </p> <p>Achtung!</p> <p>F\u00fcr einen produktiven oder \u00f6ffentlichen Einsatz ist das offensichtlich NICHT empfehlenswert.</p> DockerManuelle Installation <p>Folgenden Befehl ausf\u00fchren, um eine Konsole im Container zu erhalten: <pre><code>docker exec -it rita-http /bin/sh\n</code></pre></p> <p>In das Arbeitsverzeichnis wechseln, indem der Server liegt (selber Ordner, der auch <code>package.json</code> enth\u00e4lt)</p> <p>Anschlie\u00dfend <code>node . --config</code> ausf\u00fchren, um den Konfigurationsassistenten zu starten. Dann \"API Key Management\" ausw\u00e4hlen, dann \"Edit\" und dann \"Public Access (*)\". Den Namen unver\u00e4ndert lassen und dann alle Berechtigungen gew\u00e4hren, indem man entweder \"y\" oder \"enter\" dr\u00fcckt. Anschlie\u00dfend kann der Konfigurator wieder geschlossen werden.</p> <p>In diesem Konfigurator k\u00f6nnen auch eigene API Keys erstellt/verwaltet/gel\u00f6scht werden.</p>"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/","title":"Den Server ausprobieren","text":"<p>Zum Ausprobieren des Servers eignet sich die SwaggerUI. Diese findet sich, wie bereits im letzten Kapitel erw\u00e4hnt, unter http://localhost:3000/docs. Dort sind auch die Endpunkte dokumentiert. Eine kurze Zusammenfassung:</p> Method URL Description GET /rulesets Gibt eine Liste aller Rulesets zur\u00fcck GET /rulesets/{rulesetID} Gibt das Ruleset mit der \u00fcbergebenen ID zur\u00fcck POST /rulesets/{rulesetID} Speichert das gepostete Ruleset mit der \u00fcbergebenen ID. \u00dcberschreibt, falls ID bereits existiert DELETE /rulesets/{rulesetID} L\u00f6scht das Ruleset mit der \u00fcbergebenen ID POST /evaluate/{rulesetID} Evaluiert die Regel, die die gegebene ID besitzt, mit den geposteten Daten aus"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/#ruleset-speichern","title":"Ruleset speichern","text":"<p>Speichern wir zun\u00e4chst das vorhin erstellte Ruleset. <pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"example1\",\n      \"rule\": {\n        \"type\": \"and\",\n        \"arguments\": [\n          {\n            \"type\": \"atom\",\n            \"path\": \"hatComputer\"\n          },\n          {\n            \"type\": \"not\",\n            \"arguments\": [\n              {\n                \"type\": \"atom\",\n                \"path\": \"mitarbeiter\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/#ruleset-speichern_1","title":"Ruleset speichern","text":"<p>Um ein Ruleset zu speichern, m\u00fcssen wir es gegen den Endpunkt <code>/rulesets/{id}</code> posten. Die ID ist hierbei frei w\u00e4hlbar, sollte aber unbelegt sein, da ein etwaiges anderes Ruleset mit derselben ID sonst \u00fcberschrieben wird.</p> Swagger UICurl <p>Wir k\u00f6nnen zum Testen der Endpunkte die Swagger UI verwenden. Einmal ge\u00f6ffnet klicken wir den gew\u00fcnschten Endpunkt (<code>POST /rulesets/{rulesetID}</code>) an. In dem sich \u00f6ffnenden Bereich w\u00e4hlen wir nun \"Try it out\". Anschlie\u00dfend muss im Feld <code>rulesetID</code> die oben beschriebene ID eingegeben werden, in den Request Body wird das Ruleset selbst kopiert. Dann nur noch auf \"Execute\" klicken. Als Antwort sollte der Server den Statuscode 201 liefern.</p> <p>Zun\u00e4chst speichern wir das Ruleset in eine Datei, z.B. <code>ruleset.json</code>. Anschlie\u00dfend kann das Ruleset gepostet werden. Als frei w\u00e4hlbare ID nimmt dieses Beispiel den Wert 0. <pre><code>curl -X POST -H \"Content-Type: application/json\" -d @ruleset.json http://localhost:3000/rulesets/0\n</code></pre></p>"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/#rulesets-ansehen","title":"Rulesets ansehen","text":"<p>Nun k\u00f6nnen wir \u00fcberpr\u00fcfen, ob unser Ruleset wirklich gespeichert wurde.</p> Swagger UICurl <p>Den Endpunkt (<code>GET /rulesets</code>) ausw\u00e4hlen, dann \"Try it out\", dann \"Execute\". </p> <pre><code>curl http://localhost:3000/rulesets\n</code></pre> <p>Im Ergebnis sollten alle bis jetzt erstellten Rulesets enthalten sein.</p> <p>Probiere auch gerne auf dieselbe Art und Weise die anderen Endpunkte aus. Ihre Funktion ist in der Swagger UI dokumentiert.</p>"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/#evaluieren","title":"Evaluieren","text":"<p>Jetzt, wo wir ein Ruleset auf dem Server erstellt haben, k\u00f6nnen wir endlich das machen, wof\u00fcr Rita eigentlich gedacht ist: Daten auf diesen Regeln auswerten. Daf\u00fcr m\u00fcssen wir die Daten an den Endpunkt <code>/evaluate/{id}</code> posten, wobei die Daten im Body \u00fcbergeben werden und die ID in der URL der ID der Regel (in unserem Fall 0) entspricht, die wir auswerten wollen. Die Daten sind frei w\u00e4hlbar, hier ein Beispiel, das zu wahr auswertet:</p> <pre><code>{\n  \"hatComputer\": true,\n  \"mitarbeiter\": false\n}\n</code></pre> Swagger UICurl <p>Den Endpunkt (<code>GET /rulesets</code>) ausw\u00e4hlen, dann \"Try it out\", dann bei rulesetID die ID (in unserem Fall 0) und beim Request Body die Daten eingeben und \"Execute\" dr\u00fccken. </p> <pre><code>curl -X POST -H \"Content-Type: application/json\" -d \"{\\\"hatComputer\\\": true,\\\"mitarbeiter\\\": false}\" http://localhost:3000/evaluate/0\n</code></pre> <p>Dabei sollte folgendes Ergebnis zur\u00fcckkommen: <pre><code>{\n  \"result\": true, // (1)\n  \"details\": [ // (2)\n    {\n      \"id\": \"example1\",\n      \"result\": true\n    }\n  ],\n  \"counts\": { // (3)\n    \"true\": 1,\n    \"false\": 0\n  }\n}\n</code></pre></p> <ol> <li>Ist das Gesamtergebnis des Rulesets. Nur dann <code>true</code>, wenn auch alle Regeln in diesem Ruleset <code>true</code> sind.</li> <li>Gibt f\u00fcr jede Regel das individuelle Ergebnis an.</li> <li>Anzahl der erf\u00fcllten und Anzahl der unerf\u00fcllten Regeln.</li> </ol>"},{"location":"2.%20Der%20Server/05_spielen_mit_dem_server/#api-keys","title":"API Keys","text":"<p>Bereits im letzten Kapitel wurde gezeigt, wie API Keys erstellt, ver\u00e4ndert und gel\u00f6scht werden k\u00f6nnen. Der API Key kann dann anschlie\u00dfend in der Swagger UI verwendet werden, indem man auf Authorize dr\u00fcckt und ihn dort eingibt. Ab dann werden Requests mit diesem API Key gestellt. Bei Curl muss der Header <code>X-API-KEY</code> mit dem API Key als Wert gesetzt werden.</p>"},{"location":"3.%20Komplexere%20Regeln/06_einleitung/","title":"Einleitung","text":"<p>Bis jetzt bestehen unsere Regeln lediglich aus Atomen, die wahr oder falsch liefern und den logischen Verkn\u00fcpfungen und/oder/nicht. Rita kann aber noch viel mehr. Und dieses \"viel mehr\" soll in diesem Kapitel besprochen werden.</p>"},{"location":"3.%20Komplexere%20Regeln/07_vergleiche/","title":"Vergleiche","text":"<p>Bei Vergleichen werden, wie der Name schon vermuten l\u00e4sst, die beiden Argumente miteinander verglichen und es wird ein entsprechender Wahrheitswert zur\u00fcckgegeben. Verglichen werden k\u00f6nnen Zahlen, Strings und Datumsangaben. M\u00f6gliche Varianten sind</p> <ul> <li>equals: Die beiden Argumente sind identisch</li> <li>greater: Das erste Argument ist (lexikalisch) gr\u00f6\u00dfer als das zweite</li> <li>smaller: Das erste Argument ist (lexikalisch) kleiner als das zweite</li> <li>smallerOrEqual: Das erste Argument ist (lexikalisch) kleiner als oder genauso gro\u00df wie das zweite</li> <li>greaterOrEqual: Das erste Argument ist (lexikalisch) gr\u00f6\u00dfer als oder genauso gro\u00df wie das zweite</li> </ul>"},{"location":"3.%20Komplexere%20Regeln/07_vergleiche/#form-eines-vergleichs","title":"Form eines Vergleichs","text":"<pre><code>{\n  \"type\": \"comparison\",\n  \"operation\": \"equals\" // (1),\n  \"arguments\": [\n    // Die beiden zu vergleichenden Argumente\n  ]\n}\n</code></pre> <ol> <li>Oder eine der anderen Varianten</li> </ol>"},{"location":"3.%20Komplexere%20Regeln/07_vergleiche/#beispiel","title":"Beispiel","text":"<p>Ein Beispielruleset, das einen numerischen und einen lexikalischen Vergleich enth\u00e4lt: <pre><code>{\n  \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n  \"rules\": [\n    {\n      \"id\": \"numbers\",\n      \"rule\": {\n        // This evaluates to 5&gt;2\n        \"type\": \"comparison\",\n        \"operation\": \"greater\",\n        \"arguments\": [\n          5,\n          2\n        ]\n      }\n    },\n    {\n      \"id\": \"strings\",\n      \"rule\": {\n        // Check two Strings for equality\n        \"type\": \"comparison\",\n        \"operation\": \"equal\",\n        \"arguments\": [\n          \"test\",\n          \"test1\"\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/08_mathematik/","title":"Berechnungen","text":"<p>In einem Ruleset k\u00f6nnen auch Berechnungen ausgef\u00fchrt werden. Diese Berechnungen k\u00f6nnen jedoch nicht die Wurzel einer Regel sein, da Regeln ja stets zu wahr oder falsch ausgewertet werden m\u00fcssen. Das bedeutet, dass Berechnungen stets innerhalb eines Vergleiches sein m\u00fcssen. \"<code>Preis ohne Steuer</code>\" ist zum Beispiel keine g\u00fcltige Regel, \"<code>Preis ohne Steuer ist kleiner als 10</code>\" hingegen schon.</p>"},{"location":"3.%20Komplexere%20Regeln/08_mathematik/#berechnungen-mit-zahlen","title":"Berechnungen mit Zahlen","text":"<p>Angenommen, wir wollen \u00fcberpr\u00fcfen, dass der Nutzer <code>George</code> nicht mehr als 20% aller Computer im B\u00fcro besitzt und wir bekommen durch die Daten sowohl die Anzahl aller Computer im B\u00fcro, als auch die Anzahl der Computer pro Nutzer in folgender Form: <pre><code>{\n    \"anzahlComputer\": 10,\n    \"computerProNutzer\": {\n        \"George\": 2,\n        \"Maggie\": 5,\n        \"Albert\": 2,\n        \"Silas\": 1\n    }\n}\n</code></pre> Als Graph dargestellt baut sich die Regel wie folgt auf: <pre><code>graph\n\nv1(\"Vergleich (smallerEquals)\") --&gt; b(\"Berechnung (Division)\")\nv1 --&gt; p(\"0.2\")\nb --&gt; cpn(\"computerProNutzer.George\")\nb --&gt; ac(anzahlComputer)</code></pre> Um den Prozentsatz zu berechnen, teilen wir zun\u00e4chst die Zahl der Computer des Nutzers durch die Zahl aller Computer und vergleichen das Ergebnis dann mit der Option \"kleiner Gleich\" mit der Zahl 0.2 (=20%).</p> <p>In einer Rita Regel sieht das aus wie folgt: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"comparison\",\n                \"operation\": \"smallerOrEqual\",\n                \"arguments\": [\n                    {\n                        \"type\": \"calculation\",\n                        \"operation\": \"divide\",\n                        \"arguments\": [\n                            {\n                                \"type\": \"atom\",\n                                \"path\": \"computerProNutzer.George\"\n                            },\n                            {\n                                \"type\": \"atom\",\n                                \"path\": \"anzahlComputer\"\n                            }\n                        ]\n                    },\n                    0.2\n                ]\n            }\n        }\n    ]\n}\n</code></pre> M\u00f6gliche Operationen f\u00fcr Berechnungen sind:</p> <ul> <li><code>add</code>: Addiert die beiden Argumente</li> <li><code>subtract</code>: Subtrahiert das zweite vom ersten Argument</li> <li><code>multiply</code>: Multipliziert die beiden Argumente</li> <li><code>divide</code>: Teilt das erste durch das zweite Argument</li> <li><code>modulo</code>: Berechnet den Rest der Division Argument1/Argument2. (z.B. <code>mod(11,3)=2</code>)</li> </ul>"},{"location":"3.%20Komplexere%20Regeln/08_mathematik/#berechnungen-mit-datumsangaben","title":"Berechnungen mit Datumsangaben","text":"<p>Rita kann nicht nur mit Zahlen rechnen, sondern auch mit Daten. Ein Datum kann dabei entweder mit oder ohne Uhrzeit vorliegen (<code>\"2022-12-24\"</code> oder <code>\"2022-12-24:08:07.325\"</code>).</p>"},{"location":"3.%20Komplexere%20Regeln/08_mathematik/#abstand-zwischen-zwei-zeitpunkten","title":"Abstand zwischen zwei Zeitpunkten","text":"<p>Nehmen wir an, wir wollen \u00fcberpr\u00fcfen ob ein Nutzer zum Zeitpunkt eines wichtigen Datums j\u00fcnger als 18 Jahre war und bekommen in den Daten das wichtige Datum und seinen Geburtstag. <pre><code>{\n    \"wichtigesDatum\": \"2022-08-21\",\n    \"geburtstag\": \"2005-03-18\"\n}\n</code></pre> Der Abstand zwischen zwei Zeitpunkten ist in Rita definiert als die Subtraktion des sp\u00e4teren Datums vom fr\u00fcheren, in unserem Fall also <code>wichtigesDatum - geburtstag</code>. Das Ergebnis ist dann eine Zahl, die L\u00e4nge des Intervalls angibt. Bei der Berechnungen mit Daten gibt es noch zwei wichtige Properties im Berechnungsobjekt in JSON, n\u00e4mlich <code>dateResultUnit</code> und <code>dateCalculationUnit</code>. Beide k\u00f6nnen auf folgende Werte gesetzt werden:</p> <ul> <li><code>seconds</code></li> <li><code>minutes</code></li> <li><code>hours</code></li> <li><code>days</code></li> <li><code>months</code></li> <li><code>years</code></li> </ul> <p>Achtung</p> <p>Bei den Einheiten <code>month</code> und <code>year</code> k\u00f6nnen unter Umst\u00e4nden durch die Umrechnung Ungenauigkeiten auftreten</p> <p><code>dateResultUnit</code> gibt an in welcher Einheit das Ergebnis sein soll. Wenn also der Abstand zwischen zwei Daten bestimmt wird, gibt dieser Wert an, ob das Ergebnis in Jahren, Tagen, ... angegeben werden soll.</p> <p><code>dateCalculationUnit</code> gibt bei bei den weiter unten ausgef\u00fchrten Berechnungen mit einem Datum und einem Zeitintervall die Einheit des durch eine Zahl angegebenen Zeitintervalls an.</p> <p>Nun zur\u00fcck zu unserem Beispiel. Es ergibt sich die folgende Regel: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"comparison\",\n                \"operation\": \"smaller\",\n                \"arguments\": [\n                    {\n                        \"type\": \"calculation\",\n                        \"operation\": \"subtract\",\n                        \"dateResultUnit\": \"years\",\n                        \"arguments\": [\n                            {\n                                \"type\": \"atom\",\n                                \"path\": \"wichtigesDatum\"\n                            },\n                            {\n                                \"type\": \"atom\",\n                                \"path\": \"geburtstag\"\n                            }\n                        ]\n                    },\n                    18\n                ]\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/08_mathematik/#datumsangaben-und-zeitintervallen","title":"Datumsangaben und Zeitintervallen","text":"<p>Mit <code>add</code> und <code>subtract</code> k\u00f6nnen auch Zeitintervalle auf ein Datum addiert, bzw. von einem Datum abgezogen werden. Diese Berechnungen liefern ein Datum als Ergebnis, das Intervall wird durch eine Zahl angeben, deren Einheit mit <code>dateCalculationUnit</code> gesetzt werden kann.</p> <p>Wollen wir zum Beispiel \u00fcberpr\u00fcfen, ob der Tag vor dem Geburtstag des Nutzers tats\u00e4chlich vor dem Geburtstag liegt (ein Beispiel f\u00fcr eine Regel, die immer wahr w\u00e4re), k\u00f6nnten wir das mit folgender Regel tun: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"comparison\",\n                \"operation\": \"smaller\",\n                \"arguments\": [\n                    {\n                        \"type\": \"calculation\",\n                        \"operation\": \"subtract\",\n                        \"dateCalculationUnit\": \"days\",\n                        \"arguments\": [\n                            {\n                                \"type\": \"atom\",\n                                \"path\": \"geburtstag\"\n                            },\n                            1\n                        ]\n                    },\n                    {\n                        \"type\": \"atom\",\n                        \"path\": \"geburtstag\"\n                    }\n                ]\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/09_macros/","title":"Macros","text":"<p>Es gibt zwei Arten von Macros: Das <code>now</code> Macro und das <code>length</code> Macro</p>"},{"location":"3.%20Komplexere%20Regeln/09_macros/#now","title":"now","text":"<p>Dieses Macro gibt zum Zeitpunkt der Evaluation die aktuelle DateTime, also Datum und Uhrzeit zur\u00fcck. Es kann f\u00fcr Berechnungen mit Datumsangaben oder Vergleiche verwendet werden. Ein Beispiel daf\u00fcr w\u00e4re eine Regel, die besagt, dass ein angegebenes Datum in der Zukunft liegen muss: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"comparison\",\n                \"operation\": \"greater\",\n                \"arguments\": [\n                    {\n                        \"type\": \"atom\",\n                        \"path\": \"datumDasInDerZukunftSeinMuss\"\n                    },\n                    {\n                        \"type\": \"macro\",\n                        \"macro\": {\n                            \"type\": \"now\"\n                        }\n                    }\n                ]\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/09_macros/#length","title":"length","text":"<p>Dieses Macro gibt die L\u00e4nge eines Arrays als Zahl zur\u00fcck. Nehmen wir an, wir bekommen bei der Evaluation eine Liste der Mitarbeiter \u00fcbergeben: <pre><code>{\n    \"mitarbeiter\": [\n        \"ma1\",\n        \"ma2\",\n        \"ma3\",\n        \"ma4\",\n        \"ma5\",\n    ]\n}\n</code></pre> Unsere Regel soll nun \u00fcberpr\u00fcfen, dass die Firma mehr als drei Mitarbeiter hat: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"comparison\",\n                \"operation\": \"greater\",\n                \"arguments\": [\n                    {\n                        \"type\": \"macro\",\n                        \"macro\": {\n                            \"type\": \"length\",\n                            \"array\": {\n                                \"type\": \"atom\",\n                                \"path\": \"mitarbeiter\"\n                            }\n                        }\n                    },\n                    3\n                ]\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/10_quantoren/","title":"Quantoren","text":"<p>Es gibt zwei unterschiedliche Quantoren: <code>forall</code> und <code>exists</code>.</p> <p><code>forall</code> testet, ob eine Regel f\u00fcr alle Elemente eines Arrays gilt, <code>exists</code> testet, ob es in einem Array mindestens ein Element gibt, das diese Regel erf\u00fcllt.</p> <p>Betrachten wir nun ein Beispiel, in dem alle Elemente eines Arrays gr\u00f6\u00dfer als 12 sein sollen. Die \u00fcbergebenen Daten entsprechen folgendem Beispiel: <pre><code>{\n    \"zahlen\": [\n        14,15,16,17,122,123,124,122\n    ]\n}\n</code></pre> Die dazugeh\u00f6rige Regel sieht aus wie folgt: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"forall\",\n                \"array\":{\n                    \"type\": \"atom\",\n                    \"path\": \"zahlen\"\n                },\n                \"placeholder\": \"zahl\",\n                \"rule\": {\n                    \"type\": \"comparison\",\n                    \"operation\": \"greater\",\n                    \"arguments\": [\n                        {\n                            \"type\": \"atom\",\n                            \"path\": \"zahl\"\n                        },\n                        12\n                    ]\n                }\n            }\n        }\n    ]\n}\n</code></pre></p> <p>Das Bedarf ein bisschen Erkl\u00e4rung. Der Beginn der Regel ist ganz normal: Als <code>type</code> wird einfach <code>forall</code> angegeben (bei mindestens einem w\u00e4re es entsprechend <code>exists</code>). Mit <code>array</code> wird angegeben, in welchem Array alle Elemente bzw. mindestens ein Element eine Regel erf\u00fcllen soll(en).</p> <p><code>rule</code> gibt die Regel an, gegen die die Elemente des Arrays getestet werden sollen</p> <p><code>placeholder</code> ist der Name, unter dem der Wert im Array, der gerade getestet wird, verwendet werden kann. Sollte unter dem Key, der in <code>placeholder</code> gegeben ist, bereits ein Wert in den \u00fcbergebenen Daten existieren, wird dieser innerhalb der Regel des Quantors durch das aktuelle Element des Arrays \u00fcberschrieben. Weiterhin ist der <code>placeholder</code> auch nur innerhalb der im Quantor spezifizierten <code>rule</code> verwendbar.</p> <p>Ein weiteres Beispiel, diesmal mit <code>exists</code>: Wir wollen pr\u00fcfen, ob in einer Liste an Teilnehmern, mindestens ein Teilnehmer mit dem Namen Julian ist. Das Format der Daten sei wie in diesem Beispiel:  <pre><code>{\n    \"teilnehmer\": [\n        \"Julian\",\n        \"Luisa\",\n        \"Celina\",\n        \"Freddy\"\n    ]\n}\n</code></pre> Die Regel lautet dann wie folgt: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"exists\",\n                \"array\": {\n                    \"type\": \"atom\",\n                    \"path\": \"teilnehmer\"\n                }, \n                \"placeholder\": \"name\",\n                \"rule\": {\n                    \"comment\": \"Diese Regel wird f\u00fcr alle Zahlen im array zahlen \u00fcberpr\u00fcft\",\n                    \"type\": \"comparison\",\n                    \"operation\": \"equal\",\n                    \"arguments\": [\n                        {\n                            \"type\": \"atom\",\n                            \"path\": \"name\"\n                        },\n                        \"Julian\"\n                    ]\n                }\n            }\n        }\n    ]\n}\n</code></pre></p>"},{"location":"3.%20Komplexere%20Regeln/11_plugins/","title":"Plugins","text":"<p>Rita unterst\u00fctzt auch Plugins. Diese sind nicht Teil der Standardfunktionalit\u00e4t und m\u00fcssen hinzugef\u00fcgt werden. Aktuell sind im Rita HTTP Server alle verf\u00fcgbaren Plugins installiert, wenn man den Server aufruft steht in der Willkommensnachricht auch eine Liste aller installierten Plugins, z.B.: <pre><code>{\n  \"version\": \"3.1.2\",\n  \"message\": \"Welcome to the RITA API. A documentation is available under ./docs.\",\n  \"ritaVersion\": \"4.0.0\",\n  \"plugins\": [\n    {\n      \"name\": \"http\",\n      \"version\": \"1.1.0\"\n    }\n  ]\n}\n</code></pre> Eine Liste der verf\u00fcgbaren Plugins findet sich unter https://github.com/educorvi/rita/tree/develop/plugins/. Nutzer k\u00f6nnen auch eigene Plugins entwickeln, das Konzept dahinter ist simpel: Das Plugin bekommt \u00fcber die Regel eine Liste von Optionen, sowie die aktuellen Daten, kann mit diesen dann beliebige Aktionen ausf\u00fchren und das Ergebnis dieser Aktionen nutzen, um die Daten f\u00fcr die im Pluginblock angegebene Regel anzureichern. Die Optionen sind beliebig festlegbar. Im Folgenden wird das am Beispiel des HTTP Plugins, das w\u00e4hrend der Auswertung einer Regel einen HTTP-Request ausf\u00fchrt, demonstriert.</p> <p>Angenommen wir wollen bei der Auswertung der Daten die Daten an die URL <code>https://example.com/api1</code> posten, und die Antwort, die vom Server im JSON-Format gesendet wird, in unseren Datensatz einspeisen.</p> <p>Angenommen, die API liefert folgende Antwort:  <pre><code>{\n    \"message\": \"super\",\n    \"number\": 27\n}\n</code></pre></p> <p>Wir k\u00f6nnen nun in der Regel, die innerhalb des Plugins definiert ist, diese beiden Werte verwenden, auch wenn sie nicht von Anfang an in den \u00fcbergebenen Daten waren: <pre><code>{\n    \"$schema\": \"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json\",\n    \"rules\": [\n        {\n            \"id\": \"beispiel\",\n            \"rule\": {\n                \"type\": \"and\",\n                \"arguments\": [\n                    {\n                        \"type\": \"atom\",\n                        \"path\": \"irgendwasDasSchonInDenDatenIst\"\n                    },\n                    {\n                        \"type\": \"plugin\",\n                        \"name\": \"http\",\n                        \"options\": {\n                            \"url\": \"https://example.com/api1\",\n                            \"method\": \"POST\"\n                        },\n                        \"formula\" : {\n                            // Hier k\u00f6nnen wir jetzt message und number verwenden\n                            \"type\": \"comparison\",\n                            \"operation\": \"equal\",\n                            \"arguments\": [\n                                {\n                                    \"type\": \"atom\",\n                                    \"path\": \"number\"\n                                },\n                                27\n                            ]\n                        }\n                    }\n                ]\n            }\n        }\n    ]\n}\n</code></pre></p>"}]}